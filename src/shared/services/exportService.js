const PDFDocument = require('pdfkit');
const XLSX = require('xlsx');
const moment = require('moment');
const fs = require('fs');
const path = require('path');

class ExportService {
  constructor() {
    this.tempDir = path.join(__dirname, '../../../temp');
    this.ensureTempDir();
  }

  ensureTempDir() {
    if (!fs.existsSync(this.tempDir)) {
      fs.mkdirSync(this.tempDir, { recursive: true });
    }
  }

  /**
   * Generate PDF report
   */
  async generatePDF(options) {
    const {
      title,
      data,
      columns,
      metadata = {},
      customizations = {}
    } = options;

    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument({
          margin: 50,
          size: 'A4'
        });

        const chunks = [];
        doc.on('data', chunk => chunks.push(chunk));
        doc.on('end', () => resolve(Buffer.concat(chunks)));

        // Header
        this.addPDFHeader(doc, title, metadata);
        
        // Content
        if (Array.isArray(data) && data.length > 0) {
          this.addPDFTable(doc, data, columns, customizations);
        } else if (customizations.customContent) {
          customizations.customContent(doc);
        }

        // Footer
        this.addPDFFooter(doc, metadata);

        doc.end();
      } catch (error) {
        reject(error);
      }
    });
  }

  /**
   * Generate Excel file
   */
  generateExcel(options) {
    const {
      title,
      data,
      sheetName = 'Report',
      metadata = {}
    } = options;

    const workbook = XLSX.utils.book_new();
    
    // Create worksheet
    let worksheetData = [];

    // Add metadata header
    if (metadata.generatedBy) {
      worksheetData.push([`Generated by: ${metadata.generatedBy}`]);
      worksheetData.push([]);
    }
    
    if (metadata.dateGenerated) {
      worksheetData.push([`Generated on: ${moment(metadata.dateGenerated).format('YYYY-MM-DD HH:mm:ss')}`]);
      worksheetData.push([]);
    }

    if (title) {
      worksheetData.push([title]);
      worksheetData.push([]);
    }

    // Add data
    if (Array.isArray(data) && data.length > 0) {
      // Extract headers from first object
      const headers = Object.keys(data[0]);
      worksheetData.push(headers);

      // Add data rows
      data.forEach(row => {
        const rowData = headers.map(header => {
          let value = row[header];
          // Format dates
          if (value && moment(value, moment.ISO_8601, true).isValid()) {
            value = moment(value).format('YYYY-MM-DD HH:mm:ss');
          }
          return value || '';
        });
        worksheetData.push(rowData);
      });
    }

    const worksheet = XLSX.utils.aoa_to_sheet(worksheetData);
    
    // Auto-adjust column widths
    const columnWidths = [];
    worksheetData.forEach(row => {
      row.forEach((cell, index) => {
        const cellLength = String(cell || '').length;
        columnWidths[index] = Math.max(columnWidths[index] || 0, cellLength);
      });
    });

    worksheet['!cols'] = columnWidths.map(width => ({ width: Math.min(width + 2, 50) }));

    XLSX.utils.book_append_sheet(workbook, worksheet, sheetName);

    return XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' });
  }

  /**
   * Add PDF header
   */
  addPDFHeader(doc, title, metadata) {
    // Logo placeholder or company name
    doc.fontSize(20).text('Plaza Lama', 50, 50);
    doc.fontSize(16).text(title, 50, 80);
    
    // Metadata
    let yPosition = 110;
    if (metadata.dateGenerated) {
      doc.fontSize(10).text(`Generated: ${moment(metadata.dateGenerated).format('YYYY-MM-DD HH:mm:ss')}`, 400, yPosition);
      yPosition += 15;
    }
    
    if (metadata.generatedBy) {
      doc.fontSize(10).text(`By: ${metadata.generatedBy}`, 400, yPosition);
      yPosition += 15;
    }

    if (metadata.totalRecords) {
      doc.fontSize(10).text(`Total Records: ${metadata.totalRecords}`, 400, yPosition);
      yPosition += 15;
    }

    // Line separator
    doc.moveTo(50, yPosition + 10)
       .lineTo(550, yPosition + 10)
       .stroke();

    return yPosition + 30;
  }

  /**
   * Add PDF table
   */
  addPDFTable(doc, data, columns, customizations = {}) {
    let yPosition = 150;
    const pageHeight = doc.page.height - 100;
    const rowHeight = 20;
    const headerHeight = 25;

    // Table configuration
    const tableWidth = 500;
    const columnWidth = tableWidth / columns.length;

    // Header
    doc.fontSize(10).font('Helvetica-Bold');
    columns.forEach((column, index) => {
      const xPosition = 50 + (index * columnWidth);
      doc.text(column.header || column.key, xPosition, yPosition, {
        width: columnWidth - 5,
        align: column.align || 'left'
      });
    });

    yPosition += headerHeight;

    // Header underline
    doc.moveTo(50, yPosition)
       .lineTo(550, yPosition)
       .stroke();

    yPosition += 5;

    // Data rows
    doc.font('Helvetica').fontSize(9);
    data.forEach((row, rowIndex) => {
      // Check if we need a new page
      if (yPosition + rowHeight > pageHeight) {
        doc.addPage();
        yPosition = 50;
        
        // Re-add headers on new page
        doc.fontSize(10).font('Helvetica-Bold');
        columns.forEach((column, index) => {
          const xPosition = 50 + (index * columnWidth);
          doc.text(column.header || column.key, xPosition, yPosition, {
            width: columnWidth - 5,
            align: column.align || 'left'
          });
        });
        yPosition += headerHeight + 5;
        doc.font('Helvetica').fontSize(9);
      }

      columns.forEach((column, index) => {
        const xPosition = 50 + (index * columnWidth);
        let value = row[column.key];

        // Format value based on column type
        if (column.type === 'currency') {
          value = new Intl.NumberFormat('es-DO', {
            style: 'currency',
            currency: 'DOP'
          }).format(value || 0);
        } else if (column.type === 'date') {
          value = value ? moment(value).format('YYYY-MM-DD') : '';
        } else if (column.type === 'datetime') {
          value = value ? moment(value).format('YYYY-MM-DD HH:mm') : '';
        } else if (column.type === 'number') {
          value = (value || 0).toLocaleString();
        }

        doc.text(String(value || ''), xPosition, yPosition, {
          width: columnWidth - 5,
          align: column.align || 'left'
        });
      });

      yPosition += rowHeight;

      // Add alternating row background
      if (rowIndex % 2 === 1) {
        doc.rect(50, yPosition - rowHeight, tableWidth, rowHeight)
           .fillOpacity(0.1)
           .fill('#f0f0f0')
           .fillOpacity(1);
      }
    });
  }

  /**
   * Add PDF footer
   */
  addPDFFooter(doc, metadata) {
    const pageCount = doc.bufferedPageRange().count;
    
    for (let i = 0; i < pageCount; i++) {
      doc.switchToPage(i);
      
      // Footer line
      doc.moveTo(50, doc.page.height - 50)
         .lineTo(550, doc.page.height - 50)
         .stroke();

      // Page number
      doc.fontSize(8)
         .text(`Page ${i + 1} of ${pageCount}`, 50, doc.page.height - 40);

      // System info
      doc.text('Generated by Plaza Lama Integrated Dashboard', 350, doc.page.height - 40);
    }
  }

  /**
   * Create quote PDF
   */
  async generateQuotePDF(quote, client, items) {
    const doc = new PDFDocument({ margin: 50 });

    return new Promise((resolve, reject) => {
      const chunks = [];
      doc.on('data', chunk => chunks.push(chunk));
      doc.on('end', () => resolve(Buffer.concat(chunks)));

      try {
        // Header
        doc.fontSize(24).text('COTIZACIÓN', 50, 50, { align: 'center' });
        doc.fontSize(12).text(`No. ${quote.quote_number}`, 450, 70);

        // Company info
        doc.fontSize(14).text('Plaza Lama', 50, 100);
        doc.fontSize(10).text('República Dominicana', 50, 120);

        // Client info
        doc.fontSize(12).text('CLIENTE:', 50, 160);
        doc.fontSize(10)
           .text(`Nombre: ${client.name}`, 50, 180)
           .text(`Email: ${client.email}`, 50, 195)
           .text(`Teléfono: ${client.phone || 'N/A'}`, 50, 210)
           .text(`Empresa: ${client.company || 'N/A'}`, 50, 225);

        // Quote info
        doc.text(`Fecha: ${moment(quote.created_at).format('DD/MM/YYYY')}`, 350, 180);
        doc.text(`Válida hasta: ${quote.valid_until ? moment(quote.valid_until).format('DD/MM/YYYY') : 'N/A'}`, 350, 195);

        // Items table
        let yPos = 270;
        
        // Table headers
        doc.fontSize(10).font('Helvetica-Bold');
        doc.text('Descripción', 50, yPos);
        doc.text('Cant.', 350, yPos);
        doc.text('Precio', 400, yPos);
        doc.text('Total', 480, yPos);
        
        yPos += 20;
        doc.moveTo(50, yPos).lineTo(550, yPos).stroke();
        yPos += 10;

        // Items
        doc.font('Helvetica').fontSize(9);
        let subtotal = 0;
        
        items.forEach(item => {
          const itemTotal = parseFloat(item.quantity) * parseFloat(item.price);
          subtotal += itemTotal;

          doc.text(item.product_name, 50, yPos, { width: 280 });
          doc.text(item.quantity.toString(), 350, yPos);
          doc.text(`$${parseFloat(item.price).toFixed(2)}`, 400, yPos);
          doc.text(`$${itemTotal.toFixed(2)}`, 480, yPos);
          
          yPos += 25;
        });

        // Totals
        yPos += 20;
        doc.moveTo(350, yPos).lineTo(550, yPos).stroke();
        yPos += 15;

        const itbis = subtotal * 0.18;
        const total = subtotal + itbis;

        doc.fontSize(10).font('Helvetica-Bold');
        doc.text('Subtotal:', 400, yPos);
        doc.text(`$${subtotal.toFixed(2)}`, 480, yPos);
        yPos += 15;

        doc.text('ITBIS (18%):', 400, yPos);
        doc.text(`$${itbis.toFixed(2)}`, 480, yPos);
        yPos += 15;

        doc.text('TOTAL:', 400, yPos);
        doc.text(`$${total.toFixed(2)}`, 480, yPos);

        // Notes
        if (quote.notes) {
          yPos += 40;
          doc.fontSize(10).font('Helvetica');
          doc.text('Notas:', 50, yPos);
          doc.text(quote.notes, 50, yPos + 15, { width: 500 });
        }

        doc.end();
      } catch (error) {
        reject(error);
      }
    });
  }

  /**
   * Clean up temporary files
   */
  cleanup() {
    // Clean files older than 1 hour
    const oneHourAgo = Date.now() - (60 * 60 * 1000);
    
    if (fs.existsSync(this.tempDir)) {
      const files = fs.readdirSync(this.tempDir);
      files.forEach(file => {
        const filePath = path.join(this.tempDir, file);
        const stats = fs.statSync(filePath);
        
        if (stats.mtime.getTime() < oneHourAgo) {
          fs.unlinkSync(filePath);
        }
      });
    }
  }
}

module.exports = new ExportService();